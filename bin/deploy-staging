#!/bin/bash

export PGCLIENTENCODING=UTF8

#echo "x.x.1.181" >  ~/.default.sead.server
#echo "x" >  ~/.default.sead.username

DEFAULT_SOURCE_DB_NAME=sead_master_9
DEFAULT_SOURCE_DUMP_FILE="./starting_point/sead_master_9_public.sql.gz"

DOT_HOST_FILE=~/vault/.default.sead.server
DOT_USER_FILE=~/vault/.default.sead.username
DOT_SQITCH_FILE=~/vault/.sqitch.env

g_target_name=
g_create_database=NO
g_source_type=
g_source_name=
g_conflict_resolution=rename
g_create_snapshot=NO
g_dry_run=NO
g_display_status=NO
g_sync_sequences=NO
g_target_tag=
g_target_chain_tag=
g_ignore_git_tags=NO

# sqitch_projects="utility general security subsystem sead_api"
default_projects="utility security general sead_api subsystem submissions"
sqitch_projects=$(find . -maxdepth 1 -mindepth 1 -type d -exec test -e {}/deploy \; -print)

default_server="humlabseadserv.srv.its.umu.se"

log_file="logs/"`date "+%Y%m%d%H%M%S"`_"deploy_${g_target_name}_${g_source_type}.log"

if [[ -f "$DOT_HOST_FILE" ]]; then
    dbhost=`cat $DOT_HOST_FILE`
fi
if [[ -f "$DOT_USER_FILE" ]]; then
    dbuser=`cat $DOT_USER_FILE`
fi

usage_message=$(cat <<EOF
usage: deploy-staging OPTIONS...

    --host SERVERNAME               Target server (${dbhost})
    --user USERNAME                 User on target server (${dbuser})
    --target-db-name DBNAME         Target database name. Mandatory.
    --create-database               Create a fresh database from given source.
    --create-snapshot               Create snapshot of database.
    --dry-run                       Create snapshot of database.
    --sync-sequences                Sync all sequences when deploy is done.
    --ignore-git-tags               Continue even if sqitch tag is missing in git.
    --source-type [db|dump]         Source type i.e. a database name or a dump filename.
                                    Mandatory if "--create" is specified, else ignored.
    --source [DBNAME|FILE]          Name of source database or dump file depending on source type
                                    Optional if "--create" is specified, else ignored.
                                    Default "sead_master_9" if "source_type" is "db"
                                    Default "./starting_point/sead_master_9_public.sql.gz" if "source_type" is "dump"
    --on-conflict [drop|rename]     What to do if target database exists (rename)
                                    Optional if "--create" is specified, else ignored. Default rename.
    --deploy-to-tag TAG             Sqitch deploy to tag. Optional. Set tag to "latest" for full deploy.
    --deploy-chain-to-tag TAG       Sqitch deploy entire chain of databases up to tag. Optional. Set tag to "latest" for full deploy.
    --sqitch-project PROJECT        Sqitch project to deploy

examples

Deploy changes to a new database based on sead_production_202401 and to tag @2024.03:

λ ./bin/deploy-staging --create-database --source-type db --source sead_production_202401 --deploy-to-tag @2024.03

Deploy changes to a new database from starting point (sead_master_9) to tag @2024.03:

λ ./bin/deploy-staging --create-database --source-type dump --target-db-name sead_test_202403 --deploy-to-tag @2024.03


Deploy entire sequence of monthly databases starting from sead_master_9 equal du (--source ./starting_point/sead_master_9_public.sql.gz ) and ending at tag @2022.12.
The databases will be named sead_test_yyymmm based on tag. I a database already exists then it will be renamed to sead_test_yyymmm_YYYYMMDDHHMMSS.

λ ./bin/deploy-staging --create-database --source-type dump --target-db-name sead_test --deploy-chain-to-tag @2022.12

EOF
)

POSITIONAL=()
while [[ $# -gt 0 ]]
do
    key="$1"

    case $key in
        --host)
            dbhost="$2"; shift; shift
        ;;
        --user)
            dbuser="$2"; shift; shift
        ;;
        --target-db-name)
            g_target_name="$2"; shift; shift
        ;;
        --create-snapshot)
            g_create_snapshot="YES"; shift;
        ;;
        --dry-run)
            g_dry_run="YES"; shift;
        ;;
        --sync-sequences)
            g_sync_sequences="YES"; shift;
        ;;
        --ignore-git-tags)
            g_ignore_git_tags="YES"; shift;
        ;;
        --create-database)
            g_create_database="YES"; shift;
        ;;
        --display-status)
            g_display_status="YES"; shift;
        ;;
        --source)
            g_source_name="$2";
            shift; shift
        ;;
        --sqitch-project)
            sqitch_projects="$2";
            shift; shift
        ;;
        --source-type)
            g_source_type="$2";
            if [ "$g_source_name" == "" ]; then
                if [ "$g_source_type" == "dump" ]; then
                    g_source_name=${DEFAULT_SOURCE_DUMP_FILE}
                elif [ "$g_source_type" == "db" ]; then
                    g_source_name=${DEFAULT_SOURCE_DB_NAME}
                elif [ "$g_source_type" == "database" ]; then
                    g_source_name=${DEFAULT_SOURCE_DB_NAME}
                else
                    echo "error: source-type must be db or dump"
                fi
            fi
            shift; shift
        ;;
        --deploy-to-tag)
            g_target_tag="$2"; shift; shift
        ;;
        --deploy-chain-to-tag)
            g_target_chain_tag="$2"; shift; shift
        ;;
        --on-conflict)
            g_conflict_resolution="$2"; shift; shift;
        ;;
        --*)
            echo "error: invalid option $1"
            usage
            exit 64
        *)
            POSITIONAL+=("$1") # save it in an array for later
            shift
        ;;
    esac
done


function usage() {

    echo "$usage_message"
}

function create_snapshot()
{

    if [ "${g_source_name}" == "" ]; then
        echo "error: you must specify source database name";
        usage
        exit 64
    fi

    if [ "${g_target_name}" != "" ] || [ "${g_target_tag}" != "" ]  || [ "${g_source_type}" == "dump" ] ; then
        echo "error: invalid options for snapshot";
        usage
        exit 64
    fi

    snapshot_name=./starting_point/${g_source_name}_`date "+%Y%m%d"`.sql

    if [ "$g_dry_run" == "YES" ]; then
        echo pg_dump -C -c --if-exists -d "${g_source_name}" -h "$dbhost" -F p -U $dbuser -f $snapshot_name
    else
        pg_dump -C -c --if-exists -d "${g_source_name}" -h "$dbhost" -F p -U $dbuser -f $snapshot_name
        gzip $snapshot_name
    fi
}

set -- "${POSITIONAL[@]}" # restore positional parameters


function verify_options()
{

    if [ "$dbhost" != "$default_server" ]; then
        echo "error: this script can  (for now) only be executed on $default_server";
        exit 64
    fi

    if [ "$g_create_snapshot" == "YES" ] && [ "$g_create_database" == "YES" ]; then
        echo "error: cannot create snapshot AND database at the same time"
        usage
        exit 64
    fi

    if [ "$g_target_chain_tag" != "" && "$g_target_tag" != "" ]; then
        echo "error: cannot specify both --deploy-to-tag and --deploy-chain-to-tag"
        usage
        exit 64
    fi

    if [ "$g_create_snapshot" == "YES" ]; then
        return
    fi

    if [ "$g_target_name" == "" ]; then
        echo "error: you need to specify name of target database (--target-db-name)";
        usage
        exit 64
    fi

    if [ "$g_target_name" == "sead_production" ]; then
        echo "error: you are **not** allowed to deploy directly to sead_production!";
        usage
        exit 64
    fi

    if [ "$g_create_database" == "NO" ]; then

        echo "notice: using existing target database $g_target_name";
        echo "  ==> Settings "source-db", "source-sql-file" and "source-type" is ignored.";

        if [ "${g_source_type}" != "" ] && [ "${g_source_type}" != "db" ]; then
            echo "notice: ignoring option --source-type $g_source_type (using existing db)";
            g_source_type=db
        fi

        if [ "${g_source_name}" == "" ]; then
            echo "error: missing option --source $g_source_name";
        fi

    elif [ "$g_create_database" == "YES" ]; then

        if [ "${g_source_type}" != "db" ] && [ "${g_source_type}" != "dump" ]; then
            echo "error: you need to specify a db source type (db or dump) for new database";
            usage
            exit 64
        fi

        if [ "${g_source_type}" == "" ]; then
            echo "error: source type must be specified when --create  is specified"
            usage
            exit 64
        fi

        if [ "${g_source_name}" == "" ]; then
            echo "error: source ${g_source_type} name not specified"
            usage
            exit 64
        fi

    fi

}

function setup_credentials()
{

    if [ "$SQITCH_USERNAME" == "" ]; then
        export SQITCH_USERNAME=${dbuser}
    fi

    if [ "$SQITCH_USERNAME" == "" ]; then
        echo "error: username not specified"
        usage
        exit 64
    fi

    if [ "$SQITCH_PASSWORD" == "" ]; then
        if [ -f "${DOT_SQITCH_FILE}" ]; then
            echo "info: using credentials found in vault"
            source "${DOT_SQITCH_FILE}"
        else
            echo "error: password not specified (SQITCH_PASSWORD not defined and ${DOT_SQITCH_FILE} not found)"
            usage
            exit 64
        fi
    fi
}

function dbexec() {
    db_name=$1
    sql=$2
    if [ "$g_dry_run" == "YES" ]; then
        echo psql -v ON_ERROR_STOP=1 --host=$dbhost --username=$dbuser --no-password --dbname=$db_name --command "$sql"
    else
        echo $sql >> $log_file
        psql -v ON_ERROR_STOP=1 --host=$dbhost --username=$dbuser --no-password --dbname=$db_name --command "$sql" >> $log_file
        if [ $? -ne 0 ];  then
            echo "fatal: psql command failed! Deploy aborted." >&2
            exit 64
        fi
    fi
}

function dbexecgz() {
    db_name=$1
    gz_file=$2
    if [ "$g_dry_run" == "YES" ]; then
        echo "info: executing file $gz_file on $db_name..."
    else
        echo "info: executing file $gz_file..." >> $log_file
        zcat $gz_file | psql -v ON_ERROR_STOP=1 --host=$dbhost --username=$dbuser --no-password --dbname=$db_name >> $log_file
        if [ $? -ne 0 ];  then
            echo "fatal: psql command failed! Deploy aborted." >&2
            exit 64
        fi
    fi
}

function kick_out_users() {
    echo "info: kicking out users from ${g_source_name} and ${g_target_name}..."
    sql=$(cat <<____EOF
        select pg_terminate_backend(pg_stat_activity.pid)
        from pg_stat_activity
        where pg_stat_activity.datname in ('${g_target_name}', '${g_source_name}')
          and pid <> pg_backend_pid();
____EOF
    )
    dbexec "postgres" "$sql" >& /dev/null
}

function setup_target() {

    local target_name=$1
    local create_database=$2
    local source_type=$3
    local source_name=$4
    local conflict_resolution=$5

    if [ "$create_database" != "YES" ]; then
        echo "info: using existing database ${target_name}..."
        return
    fi

    echo "info: setting up a new database ${target_name}..."

    local target_db_exists="$( psql --host=$dbhost --username=$dbuser --no-password --dbname=postgres -tAc "select 1 from pg_database where datname='${target_name}'" )"

	if [ "$target_db_exists" = "1" ]
	then

	    if [ "$conflict_resolution" == "rename" ]; then

            local deprecated_name=${target_name}_`date "+%Y%m%d%H%M%S"`

		    echo "info:  renaming ${target_name} to ${deprecated_name}..."

		    sql="alter database ${target_name} rename to ${deprecated_name};"
		    dbexec "postgres" "$sql"

	    elif [ "$conflict_resolution" == "drop" ]; then

		    echo "info:  dropping ${target_name}..."

		    sql="drop database if exists ${target_name};"
		    dbexec "postgres" "$sql"

	    else
		    echo "error:  target database ${target_name} exists. Drop database or use --on-conflict [drop|rename] to resolve"
		    exit 64
	    fi
	fi

	if [ "${source_type}" == "db" ]; then

	    if [ "${source_name}" == "" ]; then
		    echo "error:  source database not specified"
		    usage
		    exit 64
	    fi

	    echo "info:  creating database ${target_name} using template ${source_name}..."
	    dbexec "postgres" "create database ${target_name} with template ${source_name} owner sead_master;"

	elif [ "${source_type}" == "dump" ]; then

	    if [ "${source_name}" == "" ]; then
		    echo "error:  source sql.gz file not specified"
		    usage
		    exit 64
	    fi

	    echo "info:  creating database ${target_name} using dump \"$source_name\"..."
	    dbexec "postgres" "create database ${target_name} owner sead_master;"

	    dbexec "$target_name" "drop schema if exists public;"

	    echo "info:  applying source SQL script..."
	    dbexecgz "$target_name" "$source_name"

	    echo "info:  applying default permissions..."
        # FIXME: Loop and apply all gz-files found in starting_point/
	    dbexecgz "${target_name}" "./starting_point/role_permissions.sql.gz"

	fi

}


function sync_sequences()
{
    dbexec "${g_target_name}" "select sead_utility.sync_sequences();"
}


function deployed_tags()
{
    local target_name=$1
    local target_project=$2
    local target_uri="db:pg://${dbuser}@${dbhost}/${target_name}"
    echo `sqitch status --target $target_uri -C ./$target_project --show-tags | grep -E "^# +@"| awk '{ print $2 ; }' ;`
}


function check_git_tags()
{
    local target_tag=$1
    local break_if_missing=$2
    local known_release_tags=$(grep --no-filename -E "^@" */sqitch.plan | cut --delimiter=' ' --fields=1 | sort | uniq)
    for tag in $known_release_tags; do
        check_git_tag $tag $break_if_missing
        if [ "$tag" == "$target_tag" ]; then
            break
        fi
    done
}

function check_git_tag()
{
    local tag=$1
    local break_if_missing=$2
    if ! git rev-parse "$tag" >/dev/null 2>&1; then
        if [ "$break_if_missing" == "YES" ]; then
            echo "error: tag '$tag' does not exist in git."
            exit 64
        else
            echo "warning: tag '$tag' does not exist in git."
        fi
    fi
}

function deploy_to_tag()
{
    # Deploys all project to specified release tag

    local target_name=$1
    local target_tag=$2
    local source_type=$3

    if [ "$target_tag" == "" ]; then
        echo "error: target deploy tag not specified"
        exit 0
    fi

    if [ "$target_tag" == "latest" ]; then
        target_tag=
    fi

    local target_db_exists="$( psql --host=$dbhost --username=$dbuser --no-password --dbname=postgres -tAc "select 1 from pg_database where datname='${target_name}'" )"

    if [ "$target_db_exists" != "1" ]; then
        echo "error: target ${target_name} does not exist"
        exit 64
    fi

    if [ "$g_sync_sequences" == "YES" ] && [ "${source_type}" != "dump" ]; then
        echo "info: syncing sequences (prior to deploy)..."
	    sync_sequences
    fi

    local target_uri="db:pg://${dbuser}@${dbhost}/${target_name}"

    local known_release_tags=$(grep --no-filename -E "^@" */sqitch.plan | cut --delimiter=' ' --fields=1 | sort | uniq)

    for tag in $known_release_tags; do

        echo "info: deploying tag $tag"

        # for plan in $(find . -name '*.plan'); do
        #     sqitch --plan-file "$plan" tag xyz -m 'Tag xyz'
        # done

        for sqitch_project in $sqitch_projects; do

            if [ "$tag" != "" ]; then

                local tag_line=$(grep -e "^$tag " $sqitch_project/sqitch.plan)

                if [ "$tag_line" == "" ]; then
                    echo "info: skipping $sqitch_project (has no tag $tag)"
                    continue
                fi
            fi

            IFS=$' ' read -ra v_deployed_tags <<< `deployed_tags $target_name $sqitch_project`

            local is_deployed=false
            for item in "${v_deployed_tags[@]}"; do
                if [[ "$item" == "$tag" ]]; then
                    is_deployed=true
                    break
                fi
            done

            if $is_deployed; then
                echo "info: skipping $sqitch_project ($tag already deployed)"
                continue
            fi

            echo "info: deploying $sqitch_project to $tag"

            local deploy_code = 0

            if [ $g_dry_run == "YES" ]; then
                echo "info: sqitch deploy --target ${target_uri} --mode change --no-verify -C $sqitch_project" --to $tag ;
                continue ;
            else

                if [ -f "$sqitch_project/${tag}-pre-deploy-hook" ]; then
                    echo "info: running $sqitch_project/${tag}-pre-deploy-hook"
                    "$sqitch_project/${tag}-pre-deploy-hook" --target $target_uri
                fi

                sqitch deploy --target ${target_uri} --mode change --no-verify -C $sqitch_project --to $tag # >> $log_file

                deploy_code=$?

                if [ -f $sqitch_project/"${tag}-post-deploy-hook" ]; then
                    echo "info: running $sqitch_project/${tag}-post-deploy-hook..."
                    "$sqitch_project/${tag}-post-deploy-hook" --target $target_uri
                fi

            fi

            if [ deploy_code -ne 0 ];  then
                echo "error: sqitch deploy FAILED! DB is in an undefined state." >&2
                exit 64
            fi

            if [ $g_dry_run != "YES" ] && [ "$g_sync_sequences" == "YES" ]; then
                echo "info: syncing sequences (post deploy \"${sqitch_project}\")..."
                sync_sequences
            fi


        done

        if [ "$tag" == "$target_tag" ]; then
            break
        fi

    done

    # less $log_file

}


function deploy_chain_to_tag()
{
    # Deploys all databases in chain to specified release tag
    local target_name=$1
    local target_tag=$2
    local source_type=$3
    local source_name=$4

    local known_release_tags=$(grep --no-filename -E "^@" */sqitch.plan | cut --delimiter=' ' --fields=1 | sort | uniq)

    for tag in $known_release_tags; do

        tag_target_name=`echo ${target_name}_${tag} | tr -d '@.'`

        setup_target $tag_target_name $g_create_database $source_type $source_name $g_conflict_resolution
        deploy_to_tag $tag_target_name $tag $source_type

        if [ "$tag" == "$target_tag" ]; then
            break
        fi
        
        # FIXME: add flag to create each database in chain from dump
        
        source_type="db"
        source_name=$tag_target_name

    done
}

function display_project_status()
{
    echo "info: Changes not deployed in \"$g_target_name\":"
    target_uri="db:pg://${dbuser}@${dbhost}/${g_target_name}"

    for sqitch_project in $sqitch_projects; do
        echo "info: pending CRs \"$sqitch_project\": "

        sqitch status --target ${target_uri} -C $sqitch_project \
            | grep -v "^#" \
            | grep -v '^[[:space:]]*$$' \
            | grep -v "^Undeployed change" \
            | grep -v "^No changes deployed" \
            | grep -v "^Nothing to deploy";
        echo ;
    done
}

mkdir -p logs

if [ "$g_display_status" == "YES" ]; then
    display_project_status
    exit 64
fi

if [ "$g_create_snapshot" == "YES" ]; then
    create_snapshot
    exit 64
fi

git pull &> /dev/null

verify_options

if [ "$g_ignore_git_tags" != "YES" ]; then
    check_git_tag $g_target_tag "YES"
fi

setup_credentials
kick_out_users

if [ "$g_target_chain_tag" != "" ]; then
    deploy_chain_to_tag $g_target_name $g_target_chain_tag $g_source_type $g_source_name
else
    setup_target $g_target_name $g_create_database $g_source_type $g_source_name $g_conflict_resolution
    deploy_to_tag $g_target_name $g_target_tag $g_source_type
fi

